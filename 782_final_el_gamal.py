import random
from math import log
import math
from collections import OrderedDict

# method check if the number is prime
def checkprime(num: int):
    if num == 2:
        return True
    if num % 2 == 0:
        return False

    for i in range(3, int(num**0.5) + 1, 2):
        if (num % i) == 0:
            return False
    return True


# method check if g is primitive root of p
def is_root(g, prime):
    for i in range(1, prime - 1):
        # If g^i mod p is equal to 1, g is not a primitive root

        if (g**i) % prime == 1:
            return False
    return True


# method find prime root
def primitive_root(prime):
    g = random.randrange(2, prime)

    # If it is, return g
    if is_root(g, prime):
        return g
    while not is_root(g, prime):
        g = random.randrange(2, prime)
    return g


# def generate private key
def gen_c1(g, a, prime):
    return (g**a) % prime


# Encryption
def elgamal_enc(c1, k, prime):
    return (c1**k) % prime


# Mod inverse
def mod_inverse(input, prime):
    for i in range(1, prime):
        if ((input % prime) * (i % prime)) % prime == 1:
            return i
    return -1


# decryption
def decrypt(dec, enc_msg):
    return dec * enc_msg


def prime_factors(n):
    li = []
    while n % 2 == 0:
        li.append(2)
        n = n / 2

    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            li.append(i)
            n = n / i
    if n > 2:
        li.append(int(n))

    return li


def dis_log(base, num, p):
    order = p - 1
    bj = {}
    #generator = primitive_root(p)
    m = math.ceil(math.sqrt(order))
    for j in range(0, m):
        bj[j] = base**j % p

    bj = OrderedDict(sorted(bj.items()))
    # print(bj)
    c = mod_inverse(base, p)
    check = c**m % p
    for i in range(0, m):
        for k in bj.keys():
            if bj[k] == num * (check ** i) % p:
                return i*m + k


if __name__ == '__main__':

    print("--- Processing Encryption ---")
    # generate public and private keys:
    # q
    p = random.randrange(1000, 10000)
    while not checkprime(p):
        p = random.randrange(1000, 10000)
    if checkprime(p):
        print("prime number: ", p)
    # root b as public key
    root = primitive_root(p)
    print("prime root of p: ", root)

    # random number as public key
    pub_key = random.randrange(1000, 10000)

    # Alice picks out an element x from cyclic group G
    # gcd(a,p) = 1
    # any number lower than p would be relatively prime to p
    a = random.randrange(1000, p)

    # k only known by Alice
    k = random.randrange(1000, p)
    # h = root ** a
    # g^k
    # encrypt and public C1, C2
    msg = random.randrange(0, p)

    print("Plaintext msg: ", msg)
    C1 = gen_c1(root, a, p)
    C2 = elgamal_enc(C1, k, p)
    print("Alice hold: ", k)
    print("a: ", a)
    print("Alice publish: (%d, %d)" % (C1, C2))
    print("--- Processing Decryption ---")
    # dec by Bob
    # Bob select l in range 1000, p
    l = random.randrange(1000, p)
    print("Bob hold: ", l)
    B1 = C1
    B2 = elgamal_enc(B1, l, p)
    print("Bob publish: (%d, %d)" % (B1, B2))

    # check if post are equal
    C1_B = C2 ** l % p
    B1_C = B2 ** k % p
    print("b^r^l: ", C1_B, B1_C)
    # Bob compute inverse
    dec = mod_inverse(C1_B, p)
    print("inverse:", dec)
    cipher = msg * B1_C % p
    print("Ciphertext msg: ", cipher)
    # print(msg * 1943 % 6353 * 4692 % 6353)
    print("Msg after decryption: ", cipher * dec % p)

    # eavesdrop

    print("--- Processing Eavesdrop ---")
    # ciphertext is known as well as b, b^r, b^l, and prime p.
    g = root
    b = C1
    br = C2
    bl = B2

    # m could be randomly generated by Eve
    m = p

    # to get a generate C1
    print("a which generate C1: ", dis_log(g, C1, m))
    print("k which generate C2: ", dis_log(C1, C2, m))
    print("l which generate B2: ", dis_log(B1, B2, m))
    # print(dis_log(2, 3, 101))
    result = cipher * mod_inverse(br ** dis_log(b, bl, m) % m, m) % m
    print("Eavesdrop plaintext: ", result)
